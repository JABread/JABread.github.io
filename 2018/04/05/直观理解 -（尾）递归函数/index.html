<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  直观理解 -（尾）递归函数 |   Jon </title>

 
  
    <link rel="icon" href="/images/favicon.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-nav">        
   
    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <a class="header-logo" href="/">Jon</a>  

    <div class="header-menu">          
              
            

              <a class="header-menu-link" id="header-menu-home" href="/">首页</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-archives" href="/archives">归档</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-tags" href="/tags">标签</a>     

            
            
            

              <a class="header-menu-link" id="header-menu-about" href="/about">关于</a>     

            
            
            

              <a class="iconfont icon-menu-search header-menu-link" id="header-menu-search"></a>

            
                
    </div>  
    
  </nav>
</header>   

      <div class="container">       
          
          
            <section class="main">  
          

          <article class="post">
  
	<div class="post-header">

	<p class="post-title">	
		直观理解 -（尾）递归函数
	</p>
			

	<div class="meta-info">	
	<span>
		Apr 05, 2018
	</span>

	
	
		<i class="iconfont icon-words"></i>
		<span>
			4229
		</span>
	
</div>

</div> 
	 

	  <div class="post-content slideDownMin">

		

			
					<h3 id="什么是调用栈？"><a href="#什么是调用栈？" class="headerlink" title="什么是调用栈？"></a>什么是调用栈？</h3><p><strong>栈</strong> 是一种常见的数据结构，具有后进先出（LIFO）的特点。<br><strong>调用栈</strong> 则是计算机内部对函数调用所分配内存时的一种栈结构。</p>
<h3 id="什么是递归函数？"><a href="#什么是递归函数？" class="headerlink" title="什么是递归函数？"></a>什么是递归函数？</h3><p><strong>递归函数</strong> 简单的讲，就是函数在内部调用自己。</p>
<p>在编写递归函数的时候，我们要注意组成它的两个条件，分别是：<strong>基线条件</strong> 和 <strong>递归条件</strong> （也叫回归条件）。</p>
<p>递归函数其实是利用了分而治之的思想（Divide and Conquer D&amp;C），下面用一个简单的递归函数来说明。</p>
<p>假设我们现在需要一个递增函数<code>increasing(n)</code>，其实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def increasing(n = 0):</span><br><span class="line"> print(&apos;n = %d&apos; % n)</span><br><span class="line"> increasing(n + 1)</span><br></pre></td></tr></table></figure></p>
<p>我们很容易发现，这样的代码会永不休止的执行，最后会造成栈溢出，简单的说就是内存满了。因为根本没人告诉它什么时候该停下来，所以它不断的重复执行，造成无限循环。</p>
<p>假设递增的值到100的时候就不再执行，则其实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def increasing(n = 0):</span><br><span class="line"> print(&apos;n = %d&apos; % n)</span><br><span class="line"> if n == 100: // --&gt; 基线条件</span><br><span class="line">  return</span><br><span class="line"> else: // --&gt; 递归条件</span><br><span class="line">  increasing(n + 1)</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，递归条件指的是函数在内部继续调用自己，基线条件指的是函数不再调用自己的情况。</p>
<p>所谓 Divide and Conquer，分别对应的则是递归条件和基线条件。</p>
<h3 id="递归的调用栈是怎样？"><a href="#递归的调用栈是怎样？" class="headerlink" title="递归的调用栈是怎样？"></a>递归的调用栈是怎样？</h3><p>下面我们通过计算一个数的阶乘的函数进行解释。它将会有三个不同版本，分别是<strong>递归求阶乘</strong>，<strong>尾递归求阶乘</strong>，<strong>for循环求阶乘</strong>。</p>
<p>因为这里要研究递归的调用栈情况，所以我们先来看看递归求阶乘的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;####### 递归求阶乘 #######&apos;)</span><br><span class="line">def fact(n):</span><br><span class="line"> if n == 1:</span><br><span class="line">  return 1</span><br><span class="line"> else:</span><br><span class="line">  return n * fact(n - 1)</span><br><span class="line"></span><br><span class="line">print(&apos;result = %s&apos; % fact(4))</span><br></pre></td></tr></table></figure>
<p>为了更好的解释说明，我将上面的代码略作改动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;####### 递归求阶乘 #######&apos;)</span><br><span class="line">def fact(n):</span><br><span class="line"> if n == 1:</span><br><span class="line">  result = 1</span><br><span class="line">  return result</span><br><span class="line"> else:</span><br><span class="line">  print(&apos;current: n = %d, result = %d * fact(%d - 1)&apos; % (n, n, n)) </span><br><span class="line">  result = fact(n - 1) </span><br><span class="line">  return n * result</span><br></pre></td></tr></table></figure>
<p>改动理由：</p>
<ol>
<li>调用栈中的函数都保留计算结果变量 <strong>result</strong>，要特别注意的是调用栈中的各个函数内部的变量对函数彼此而言是互相隔离无法访问的。</li>
<li>在递归条件中打印活跃期的情况。</li>
</ol>
<p>所谓<strong>活跃期</strong>，指的是计算机当前所操作的函数执行期。</p>
<p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">####### 递归求阶乘 #######</span><br><span class="line">current: n = 4, result = 4 * fact(4 - 1)</span><br><span class="line">current: n = 3, result = 3 * fact(3 - 1)</span><br><span class="line">current: n = 2, result = 2 * fact(2 - 1)</span><br><span class="line">result = 24</span><br></pre></td></tr></table></figure></p>
<p>其调用栈情况：</p>
<p><img src="/images/placeholder.png" alt="递归函数调用栈.png" data-src="https://user-gold-cdn.xitu.io/2017/12/17/160622c83a81d856?w=1240&amp;h=698&amp;f=png&amp;s=150455" class="lazyload"></p>
<p>正常情况下，栈顶函数执行完毕后将弹出。但我们却看到递归函数的调用不断的向调用栈压入执行函数，那么问题来了，<strong>为什么调用栈前面的函数”执行完毕”后不自动弹出呢？</strong></p>
<p>答案是 <strong>栈顶函数其实并未执行完成</strong>，因为栈顶函数的变量result的值尚未确定，它还需要 <strong>下一个递归函数返回的值（上下文）</strong> 来计算，所以一直处于非活跃期状态被保留在调用栈中。</p>
<p>上面的答案还需完善一下，因为当某个栈顶函数，例如fact(1)，在执行到基线条件时，result的值已经确定下来，而无需等待下一个递归函数的上下文，所以该栈顶函数<strong>真正执行完毕，并弹出调用栈</strong>。又因为下一个栈顶函数可以拿到已弹栈的函数返回的上下文，因而当弹栈函数<strong>交待</strong>完成后，也相继弹出调用栈。</p>
<h3 id="尾递归的调用栈是怎样？"><a href="#尾递归的调用栈是怎样？" class="headerlink" title="尾递归的调用栈是怎样？"></a>尾递归的调用栈是怎样？</h3><p>我们先来看看尾递归求阶乘的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;####### 尾递归求阶乘 #######&apos;)</span><br><span class="line">def fact_tail(n):</span><br><span class="line"> return tail_fact_count(n)</span><br><span class="line"></span><br><span class="line">def tail_fact_count(n, result = 1):</span><br><span class="line"> if n == 1:</span><br><span class="line">  return result</span><br><span class="line"> else:</span><br><span class="line">  print(&apos;current: n = %d, result = %d&apos; % (n, result))</span><br><span class="line">  print(&apos;next: n = %d, result = %d&apos; % (n - 1, result * n))</span><br><span class="line">  print(&apos;----------------&apos;)</span><br><span class="line">  return tail_fact_count(n - 1, n * result)</span><br><span class="line"></span><br><span class="line">print(&apos;result = %s&apos; % fact_tail(4))</span><br></pre></td></tr></table></figure>
<p>同样的，我们将上述代码略作改动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;####### 尾递归求阶乘 #######&apos;)</span><br><span class="line">def fact_tail(n):</span><br><span class="line"> result = tail_fact_count(n)</span><br><span class="line"> return result</span><br><span class="line"></span><br><span class="line">def tail_fact_count(n, result = 1):</span><br><span class="line"> if n == 1:</span><br><span class="line">  return result</span><br><span class="line"> else:</span><br><span class="line">  print(&apos;current: n = %d, result = %d&apos; % (n, result))</span><br><span class="line">  print(&apos;next: n = %d, result = %d&apos; % (n - 1, result * n))</span><br><span class="line">  print(&apos;----------------&apos;)</span><br><span class="line">  result = n * result</span><br><span class="line">  n = n - 1</span><br><span class="line">  return tail_fact_count(n, result)</span><br><span class="line"></span><br><span class="line">print(&apos;result = %s&apos; % fact_tail(4))</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">####### 尾递归求阶乘 #######</span><br><span class="line">current: n = 4, result = 1</span><br><span class="line">next: n = 3, result = 4</span><br><span class="line">----------------</span><br><span class="line">current: n = 3, result = 4</span><br><span class="line">next: n = 2, result = 12</span><br><span class="line">----------------</span><br><span class="line">current: n = 2, result = 12</span><br><span class="line">next: n = 1, result = 24</span><br><span class="line">----------------</span><br><span class="line">result = 24</span><br></pre></td></tr></table></figure>
<p>我们再来看看它的调用栈情况：</p>
<p><img src="/images/placeholder.png" alt="尾递归函数调用栈.png" data-src="https://user-gold-cdn.xitu.io/2017/12/17/160622c83bb8aebd?w=1240&amp;h=912&amp;f=png&amp;s=192491" class="lazyload"></p>
<p><img src="/images/placeholder.png" alt="尾递归函数调用栈.png" data-src="https://user-gold-cdn.xitu.io/2017/12/17/160622c83be2af8a?w=1240&amp;h=328&amp;f=png&amp;s=58090" class="lazyload"></p>
<p>仔细对比前面递归函数的调用栈情况，我们可以看出递归与尾递归调用栈的两个明显不同点：</p>
<ol>
<li>尾递归的调用栈明显比递归的调用栈清爽很多。</li>
<li><strong>尾递归弹栈顺序是由上至下执行；而递归弹栈顺序是由下至上执行的。</strong>（这里的弹栈顺序指的不是物理顺序）</li>
</ol>
<p>我们再来看看前面递归函数的实现。在递归实现中，result的值因为需要 <strong>下一个递归函数返回的值</strong> 来计算才能确定，所以栈顶函数（设A）一直在调用栈中停留等待下一个栈顶函数（设B）的返回值，一旦下一个栈顶函数（B）返回了确切的result值，那么当B交待完成之后就会弹出，所谓交待即是因为上一个栈顶函数A需要下一个栈顶函数即B的返回值，当A拿到了B的值就是交待完成了。以此类推，递归的弹栈顺序则如图所示由下往上弹出。</p>
<p>那么尾递归究竟做了什么猫腻？</p>
<p>尾递归其实在result的值上做了猫腻。在尾递归的实现中，result的值在当前栈顶函数中已经确定下来了，并经计算后交待给下一个栈顶函数。所以当栈顶函数<strong>完成了它的使命（把result值传递给下一个执行函数）</strong>，它就会愉快的在调用栈上弹出。</p>
<p>归纳来讲:</p>
<ul>
<li>递归函数需要将整个函数作为上下文来完成 <strong>目的</strong>。</li>
<li>尾递归则把 <strong>目的</strong> 在当前函数中完成，并交待给下一个函数。</li>
</ul>
<p>在本例子中的 <strong>目的</strong> 指的是确定result值。</p>
<h3 id="为什么说尾递归的实现在本质上是跟循环等价？"><a href="#为什么说尾递归的实现在本质上是跟循环等价？" class="headerlink" title="为什么说尾递归的实现在本质上是跟循环等价？"></a>为什么说尾递归的实现在本质上是跟循环等价？</h3><p>按照惯例，先上代码。但是为了更好的理解与尾递归的联系，最好还是花个十几秒思考一下如何实现for循环求阶乘吧~</p>
<p>为了减少篇幅，直接贴上略作修改的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;####### for循环求阶乘 #######&apos;)</span><br><span class="line">def fact_for(n):</span><br><span class="line"> if n == 1:</span><br><span class="line">  return 1</span><br><span class="line"> else:</span><br><span class="line">  result = 1</span><br><span class="line">  for i in range(n, 0, -1):</span><br><span class="line">   print(&apos;current: n = %d, result = %d&apos; % (i, result))</span><br><span class="line">   result = for_fact_count(i, result)</span><br><span class="line">  return result</span><br><span class="line">	</span><br><span class="line">def for_fact_count(n, result = 1):</span><br><span class="line"> return n * result</span><br><span class="line"></span><br><span class="line">print(&apos;result = %s&apos; % fact_for(4))</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">####### for循环求阶乘 #######</span><br><span class="line">current: n = 4, result = 1</span><br><span class="line">current: n = 3, result = 4</span><br><span class="line">current: n = 2, result = 12</span><br><span class="line">current: n = 1, result = 24</span><br><span class="line">result = 24</span><br></pre></td></tr></table></figure>
<p>当我们思考如何使用for循环去实现求阶乘的过程中，我们会想到用一个变量去存储计算的值。在上述代码中指的就是 <code>result (= 1)</code>。</p>
<p>为了便于理解for循环与尾递归，我设计了这么一个函数 <code>for_fact_count(n, result = 1)</code>，它接收 <strong>当前result值并经计算后刷新result值</strong>。</p>
<p>在不影响for循环的实现我已经将其与尾递归的实现做了相似的转化（连名字的都好相似啦），所以请开始你的表演，把for循环求阶乘的调用栈画出来吧~</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote>
<ul>
<li>虽说本文使用了Python进行编码解释，但是目前大多数编程语言都没有针对尾递归做优化，Python解释器也没有，所以即便使用了尾递归进行求阶乘，在运行过程中还是会造成栈溢出。而Xcode在debug环境下不会对尾递归做优化，需将其设为release。</li>
<li>小生才疏浅陋，文中难免有错漏之处，请多多指教，感谢您的阅读。</li>
</ul>
</blockquote>  					
					
	  </div>     
	  

	
<div class="post-meta">
      	

      	
</div>





<div class="post-footer">
  <div class="pf-left">
      <img class="pf-avatar lazyload" src="/images/placeholder.png" data-src="/images/Jon.jpeg">
      <p class="pf-des">hi,i am Jon</p>
  </div>

  <div class="pf-right">           
      <div class="pf-links">
        




<span class="donate-btn">
	<span class="iconfont icon-donate"></span>
</span>


<div id="donate-box" class="sildeUpMin">

	<span class="donate-cancel iconfont icon-cancel"></span>

	<div class="donate-img-box">
		<img id="donate-qr-wechat" class="donate-img lazyload" src="/images/placeholder.png" alt="No Donate Image!" data-src="/images/donate1.png">	
		<img id="donate-qr-alipay" class="donate-img lazyload" src="/images/placeholder.png" alt="No Donate Image!" data-src="/images/donate2.png">	
	</div>

	<span class="donate-word">世界美好 你也是</span>

	<div class="donate-list">
		<span class="iconfont icon-donate-wechat"></span>
		<span class="iconfont icon-donate-alipay"></span>
	</div>

</div>

 
        
	
<script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=21d601593a1de"></script>
	
	<span class="share-btn">
	<span class="iconfont icon-share"></span>
	</span>


	<div class="-mob-share sildeUpMin">
		   			             
            <a class="iconfont  icon-share-qq -mob-share-qq"></a>		
     	   			             
            <a class="iconfont  icon-share-weixin -mob-share-weixin"></a>		
     	   			             
            <a class="iconfont  icon-share-weibo -mob-share-weibo"></a>		
     	   			             
            <a class="iconfont  icon-share-douban -mob-share-douban"></a>		
     	   			             
            <a class="iconfont  icon-share-facebook -mob-share-facebook"></a>		
     	   			             
            <a class="iconfont  icon-share-twitter -mob-share-twitter"></a>		
     	   			             
            <a class="iconfont  icon-share-google -mob-share-google"></a>		
     	   
	</div>	

      </div>  
    <nav class="pf-paginator">
      
         
          <a href="/2018/05/06/hello-world/" data-hover="Hello World">上一篇</a>      
            
        
            
  </nav>   
  </div>
</div> 
	


    
    <div id="disqus_thread"></div>

    <script>
    (function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://'+'lemonreds'+'.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());    
    (d.head || d.body).appendChild(s);
    })();
    </script>

    <noscript>Please enable JavaScript to view the  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>


	
</article>

          </section> 
      </div>            
    
    <a id="backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    

        
        <div class="search-container sildeUpMin">


            <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">  
            <span class="search-cancel iconfont icon-cancel"></span>
          
            </div>
              
            <div id="search-result" class="search-result"></div>

        </div>
 

     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon lazyload" src="/images/placeholder.png" data-src="/images/favicon.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?636802045446222199ae541e32c8133e"; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>





     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
		
		2018		
	
		Jon
		<br>

		Built By Theme
		<a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>	
		</div>			
	 
</footer>   

  

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>