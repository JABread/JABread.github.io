<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>从iOS的世界初探微信小程序开发时收集的坑(持续更新...)</title>
      <link href="/2018/05/12/%E4%BB%8EiOS%E7%9A%84%E4%B8%96%E7%95%8C%E5%88%9D%E6%8E%A2%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%97%B6%E6%94%B6%E9%9B%86%E7%9A%84%E5%9D%91(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0...)/"/>
      <content type="html"><![CDATA[<h1 id="从iOS的世界初探微信小程序开发时收集的坑-持续更新…"><a href="#从iOS的世界初探微信小程序开发时收集的坑-持续更新…" class="headerlink" title="从iOS的世界初探微信小程序开发时收集的坑(持续更新…)"></a>从iOS的世界初探微信小程序开发时收集的坑(持续更新…)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一名勤恳单纯的未来iOS开发者，受迫于对新事物的好奇，便义无反顾地举手加入了团队里一个小程序项目的开发中。</p><blockquote><p>首先要声明一下：</p><ul><li>本人对前端了解微浅，微信小程序开发也无深入了解，这里仅作为一篇小程序的项目经验总结文来跟大家分享。</li><li>微信小程序处于发展中，内嵌的方法仍在不断改善与补充，相信一些坑也会在未来的版本中被填平。<br>本文基于的<code>基础库版本为1.5.3</code>，内容如有疏漏，欢迎指教。</li></ul></blockquote><p><img src="https://lh3.googleusercontent.com/-PWCOmWTatr4/Wva0b8eSr9I/AAAAAAAAKxU/HP6Fo14jNKkb23llMS6DNWQ509ML0CVWwCHMYCw/I/15230709916866.jpg" alt=""></p><a id="more"></a><h2 id="Dry-goods-【干货】"><a href="#Dry-goods-【干货】" class="headerlink" title="Dry goods 【干货】"></a>Dry goods 【干货】</h2><h1 id="一-值"><a href="#一-值" class="headerlink" title="一. 值"></a>一. 值</h1><h4 id="1-setData"><a href="#1-setData" class="headerlink" title="1. setData"></a>1. setData</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">setData：是逻辑层(.js)向视图层(.wxml)进行的数据渲染，是一个异步操作，所以可能需要用到延迟执行方法来确保赋值成功后的操作：</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">   </span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;, duration) // duration: 毫秒(ms)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2. </span><br><span class="line">// 在该作用域里赋值能成功而page的data数据没有更新。但似乎没必要做这样不去刷新页面数据的操作，因为不是视图层需要的数据源没必要写在data中，而且这样可能会污染该值。</span><br><span class="line">  this.data.testData = testData </span><br><span class="line">// 这是真正需要的赋值操作，刷新值后渲染页面。</span><br><span class="line">  that.setData(&#123;</span><br><span class="line">     testData: testData,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3.</span><br><span class="line">// 在闭包中用到this需首先将其引用，并且需要声明在赋值的作用域外层，否则会报`Cannot read property &apos;data&apos; of undefined`错误。</span><br><span class="line">  var that = this</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">     testData: that.data.testData2,</span><br><span class="line">  &#125;)</span><br><span class="line">// 若setData操作仍在一个闭包内，则同理写成that.setData(&#123;&#125;)。</span><br><span class="line">&#123; // 闭包</span><br><span class="line">  that.setData(&#123;</span><br><span class="line">     testData: that.data.testData2,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-小程序码传参"><a href="#2-小程序码传参" class="headerlink" title="2. 小程序码传参"></a>2. 小程序码传参</h4><p>向后端生成小程序码的请求中传入页面路径path与约定参数(test)，即可同navigator跳转方法获得类似。<br><code>onLoad: function (options) { var t = options.test }</code></p><h4 id="3-函数不支持带默认参数，有参数的函数，必须传参，而且必须每一个都传，如果是回调闭包也必须提供空操作。举个🌰"><a href="#3-函数不支持带默认参数，有参数的函数，必须传参，而且必须每一个都传，如果是回调闭包也必须提供空操作。举个🌰" class="headerlink" title="3. 函数不支持带默认参数，有参数的函数，必须传参，而且必须每一个都传，如果是回调闭包也必须提供空操作。举个🌰"></a>3. 函数不支持带默认参数，有参数的函数，必须传参，而且必须每一个都传，如果是回调闭包也必须提供空操作。举个🌰</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（network.js）声明的地方</span><br><span class="line">// 获取社团详情</span><br><span class="line">function getCommunityDetail(communityId, success, fail) &#123;</span><br><span class="line">  this.get(url.base + url.communityDetail + communityId,</span><br><span class="line">    function (res) &#123;</span><br><span class="line">      success(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    function (res) &#123;</span><br><span class="line">      fail(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> (communityInfo.js) 用到的地方</span><br><span class="line">network.getCommunityDetail(options.communityId,</span><br><span class="line">      function(success) &#123;</span><br><span class="line">      // Does something...</span><br><span class="line">      &#125;,</span><br><span class="line">      function(fail) &#123;</span><br><span class="line">     // 尽管这里可能不需要做失败处理，但仍需提供这样的空操作</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><h4 id="4-dataset"><a href="#4-dataset" class="headerlink" title="4. dataset"></a>4. dataset</h4><p><code>dataset</code>: 用于组件中传递数据<br>注意：其设置变量名与取值变量名的格式要求。（文档说明如下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   （xxx.wxml）</span><br><span class="line">&lt;view data-alpha-beta=&quot;1&quot; data-alphaBeta=&quot;2&quot; bindtap=&quot;bindViewTap&quot;&gt; DataSet Test &lt;/view&gt;</span><br><span class="line">    (xxx.js)</span><br><span class="line">Page(&#123;</span><br><span class="line">  bindViewTap:function(event)&#123;</span><br><span class="line">    event.currentTarget.dataset.alphaBeta === 1 // `-` 会转为驼峰写法</span><br><span class="line">    event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="二-组件"><a href="#二-组件" class="headerlink" title="二. 组件"></a>二. 组件</h1><blockquote><p>wx tip: 请勿在 scroll-view 中使用 textarea、map、canvas、video 组件。<br>so，注定她们是不安定的。但在这里就不一一展开了。</p></blockquote><h4 id="1-scroll-view"><a href="#1-scroll-view" class="headerlink" title="1. scroll-view"></a>1. scroll-view</h4><ul><li><p>上述组件嵌套在 scroll-view 中设置css属性 <code>z-index</code> 在真机上不起作用。</p></li><li><p>安卓端bug：scroll-view嵌套在swiper-item中横向滑动不响应，此时可设置scroll-view的css属性 <code>overflow : auto;</code> 但这又会引来一个美观问题，就是它的横向滚动条冒了出来，此时再设置</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这会导致整个scroll-view内的滚动条都被隐藏。</span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  color: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-canvas"><a href="#2-canvas" class="headerlink" title="2. canvas"></a>2. canvas</h4><ul><li><p>由于canvas的不可 `隐藏性` ，所以想直接生成图片有些阻碍，但也不是不可以，这里提供一种思路。<br>（需求场景：点击按钮生成一张由下载图片和文字画的canvas，并将其合成为图片，随即预览该图片）<br>思路：在屏幕所见范围外放置canvas，生成并保存图片后将canvas销毁(<code>wx:if</code>：用此方法销毁)。然而这里有几个让你不得不改变这样的需求的坑：<br>1：由于绘图方法drawImage未提供回调函数，所以你无法得知何时绘图完成(该回调将在未来版本中添加），对于需要区分图片层级的绘图操作尤为不好。（若图片B在图片A上，则需要先把图片A绘图成功）<br>2：由于性能问题(最好在安卓真机上测试)，尽管把延迟调的很久让绘图操作执行，但时长会发生绘图失败生成一张空白图片可能，造成用户体验不好。<br>3：特别是多图合成情况，以上问题尤为突出。<br>需求改动：将点击直接生成合成图片改为跳转到另一个page去展示并且生成。<br>当然你会想问，让后台直接返回合成的图片不就ok啦？确实是这样的，这会在后面的版本中改过来。</p></li><li><p>drawImage需是<code>项目资源图片</code>或者是<code>图片下载完毕后保存的文件路径</code>，这里要注意的是下载的图片url必须是安全校验的路径，而image标签使用的https必须经过微信签名验证，自签名不行，如本次项目使用的七牛云就出现了这样的bug：图片加载会变得非常慢甚至无法加载，但是预览图片还是会显示出来。</p></li><li><p>顺便说一下图片裁剪方法clip会在未来的版本中添加。</p></li></ul><h4 id="3-button"><a href="#3-button" class="headerlink" title="3. button"></a>3. button</h4><ul><li>按钮无法直接设置背景图<br>解决思路：把 <code>button</code> 嵌套在 <code>image</code> 中，并把 <code>button</code> 的 <code>opacity</code> 设为0，但这里要特别注意：要将<code>button</code>的css属性 <code>position</code> 设为<code>absolute</code>，设定其绝对位置，否则无法响应点击。</li></ul><h4 id="4-textarea"><a href="#4-textarea" class="headerlink" title="4. textarea"></a>4. textarea</h4><p>textarea标签的默认输入最大输入长度为140。可设置其css属性 <code>maxlength</code></p><h4 id="5-swiper"><a href="#5-swiper" class="headerlink" title="5. swiper"></a>5. swiper</h4><ol><li>设置高度时须将每个item的高度都赋值一遍，防止造成内容显示高度不一致（模拟器上显示正常，真机上内容显示有偏差）。</li><li>解决 <code>swiper-item</code> 因内容高度不一致而导致部分item无内容显示的可选方案：切换item时重载数据。</li></ol><h1 id="三-util"><a href="#三-util" class="headerlink" title="三. util"></a>三. util</h1><h4 id="1-requrie不支持绝对路径，须使用相对路径导入"><a href="#1-requrie不支持绝对路径，须使用相对路径导入" class="headerlink" title="1. requrie不支持绝对路径，须使用相对路径导入"></a>1. requrie不支持绝对路径，须使用相对路径导入</h4><p>这个bug确实很让人抓狂。</p><h4 id="2-若需要配置指定page的页面信息，在-json文件中直接配置对应属性即可，而不要写成app-json中配置所有页面信息的格式（如下）"><a href="#2-若需要配置指定page的页面信息，在-json文件中直接配置对应属性即可，而不要写成app-json中配置所有页面信息的格式（如下）" class="headerlink" title="2. 若需要配置指定page的页面信息，在.json文件中直接配置对应属性即可，而不要写成app.json中配置所有页面信息的格式（如下）"></a>2. 若需要配置指定page的页面信息，在.json文件中直接配置对应属性即可，而不要写成app.json中配置所有页面信息的格式（如下）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（app.json）：不仅有配置页面信息的`window`属性，还包括注册页面的`pages`等属性。</span><br><span class="line">&#123;</span><br><span class="line">&quot;pages&quot;: [</span><br><span class="line">    // register pages</span><br><span class="line">  ],</span><br><span class="line">  &quot;window&quot;: &#123;</span><br><span class="line">    &quot;backgroundTextStyle&quot;: &quot;light&quot;,</span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;CommunityUnion&quot;,</span><br><span class="line">    &quot;navigationBarTextStyle&quot;: &quot;black&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（页面.json）</span><br><span class="line">&#123;</span><br><span class="line">   &quot;backgroundTextStyle&quot;: &quot;light&quot;,</span><br><span class="line">   &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</span><br><span class="line">   &quot;navigationBarTitleText&quot;: &quot;页面&quot;, </span><br><span class="line">   &quot;navigationBarTextStyle&quot;: &quot;green&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-设置page背景颜色"><a href="#3-设置page背景颜色" class="headerlink" title="3. 设置page背景颜色"></a>3. 设置page背景颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在page对应的.wss文件中设置</span><br><span class="line">page &#123;</span><br><span class="line">  background-color: &quot;#f4f5f7&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对应page的.json中设置 <code>background-color</code> 属性不是修改页面的背景颜色，而是修改页面的窗口颜色，即页面下拉时出现的窗口颜色。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>开发小程序过程中给人的感觉是开发起来没有太多的自由，留给开发者的空间不够大，可喜的是微信小程序一直在进步与完善，在社区中您会非常欣（nan）喜（shou）地发现，收到的微信官方答复大多数都是：xx功能考虑在未来的版本中加入…</p><p>（收）</p>]]></content>
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>直观理解 -（尾）递归函数</title>
      <link href="/2018/04/05/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%20-%EF%BC%88%E5%B0%BE%EF%BC%89%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/"/>
      <content type="html"><![CDATA[<h2 id="直观理解-（尾）递归函数"><a href="#直观理解-（尾）递归函数" class="headerlink" title="直观理解 -（尾）递归函数"></a>直观理解 -（尾）递归函数</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>我们都见识了不少关于递归与尾递归的各种长篇概论，本文将通过对下面几个问题的直观体验，来帮助加深对递归的理解。</p></blockquote><p><strong>本文内容目录：</strong></p><ul><li>什么是调用栈？</li><li>什么是递归函数？</li><li>递归的调用栈是怎样？</li><li>尾递归的调用栈是怎样？</li><li>为什么说尾递归的实现在本质上是跟循环等价？</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/17/160622c83bf15757?w=533&amp;h=300&amp;f=jpeg&amp;s=16052" alt="Game of Thrones.jpg"></p><a id="more"></a><h3 id="什么是调用栈？"><a href="#什么是调用栈？" class="headerlink" title="什么是调用栈？"></a>什么是调用栈？</h3><p><strong>栈</strong> 是一种常见的数据结构，具有后进先出（LIFO）的特点。<br><strong>调用栈</strong> 则是计算机内部对函数调用所分配内存时的一种栈结构。</p><h3 id="什么是递归函数？"><a href="#什么是递归函数？" class="headerlink" title="什么是递归函数？"></a>什么是递归函数？</h3><p><strong>递归函数</strong> 简单的讲，就是函数在内部调用自己。</p><p>在编写递归函数的时候，我们要注意组成它的两个条件，分别是：<strong>基线条件</strong> 和 <strong>递归条件</strong> （也叫回归条件）。</p><p>递归函数其实是利用了分而治之的思想（Divide and Conquer D&amp;C），下面用一个简单的递归函数来说明。</p><p>假设我们现在需要一个递增函数<code>increasing(n)</code>，其实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def increasing(n = 0):</span><br><span class="line"> print(&apos;n = %d&apos; % n)</span><br><span class="line"> increasing(n + 1)</span><br></pre></td></tr></table></figure></p><p>我们很容易发现，这样的代码会永不休止的执行，最后会造成栈溢出，简单的说就是内存满了。因为根本没人告诉它什么时候该停下来，所以它不断的重复执行，造成无限循环。</p><p>假设递增的值到100的时候就不再执行，则其实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def increasing(n = 0):</span><br><span class="line"> print(&apos;n = %d&apos; % n)</span><br><span class="line"> if n == 100: // --&gt; 基线条件</span><br><span class="line">  return</span><br><span class="line"> else: // --&gt; 递归条件</span><br><span class="line">  increasing(n + 1)</span><br></pre></td></tr></table></figure></p><p>从上面可以看出，递归条件指的是函数在内部继续调用自己，基线条件指的是函数不再调用自己的情况。</p><p>所谓 Divide and Conquer，分别对应的则是递归条件和基线条件。</p><h3 id="递归的调用栈是怎样？"><a href="#递归的调用栈是怎样？" class="headerlink" title="递归的调用栈是怎样？"></a>递归的调用栈是怎样？</h3><p>下面我们通过计算一个数的阶乘的函数进行解释。它将会有三个不同版本，分别是<strong>递归求阶乘</strong>，<strong>尾递归求阶乘</strong>，<strong>for循环求阶乘</strong>。</p><p>因为这里要研究递归的调用栈情况，所以我们先来看看递归求阶乘的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;####### 递归求阶乘 #######&apos;)</span><br><span class="line">def fact(n):</span><br><span class="line"> if n == 1:</span><br><span class="line">  return 1</span><br><span class="line"> else:</span><br><span class="line">  return n * fact(n - 1)</span><br><span class="line"></span><br><span class="line">print(&apos;result = %s&apos; % fact(4))</span><br></pre></td></tr></table></figure><p>为了更好的解释说明，我将上面的代码略作改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;####### 递归求阶乘 #######&apos;)</span><br><span class="line">def fact(n):</span><br><span class="line"> if n == 1:</span><br><span class="line">  result = 1</span><br><span class="line">  return result</span><br><span class="line"> else:</span><br><span class="line">  print(&apos;current: n = %d, result = %d * fact(%d - 1)&apos; % (n, n, n)) </span><br><span class="line">  result = fact(n - 1) </span><br><span class="line">  return n * result</span><br></pre></td></tr></table></figure><p>改动理由：</p><ol><li>调用栈中的函数都保留计算结果变量 <strong>result</strong>，要特别注意的是调用栈中的各个函数内部的变量对函数彼此而言是互相隔离无法访问的。</li><li>在递归条件中打印活跃期的情况。</li></ol><p>所谓<strong>活跃期</strong>，指的是计算机当前所操作的函数执行期。</p><p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">####### 递归求阶乘 #######</span><br><span class="line">current: n = 4, result = 4 * fact(4 - 1)</span><br><span class="line">current: n = 3, result = 3 * fact(3 - 1)</span><br><span class="line">current: n = 2, result = 2 * fact(2 - 1)</span><br><span class="line">result = 24</span><br></pre></td></tr></table></figure></p><p>其调用栈情况：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/17/160622c83a81d856?w=1240&amp;h=698&amp;f=png&amp;s=150455" alt="递归函数调用栈.png"></p><p>正常情况下，栈顶函数执行完毕后将弹出。但我们却看到递归函数的调用不断的向调用栈压入执行函数，那么问题来了，<strong>为什么调用栈前面的函数”执行完毕”后不自动弹出呢？</strong></p><p>答案是 <strong>栈顶函数其实并未执行完成</strong>，因为栈顶函数的变量result的值尚未确定，它还需要 <strong>下一个递归函数返回的值（上下文）</strong> 来计算，所以一直处于非活跃期状态被保留在调用栈中。</p><p>上面的答案还需完善一下，因为当某个栈顶函数，例如fact(1)，在执行到基线条件时，result的值已经确定下来，而无需等待下一个递归函数的上下文，所以该栈顶函数<strong>真正执行完毕，并弹出调用栈</strong>。又因为下一个栈顶函数可以拿到已弹栈的函数返回的上下文，因而当弹栈函数<strong>交待</strong>完成后，也相继弹出调用栈。</p><h3 id="尾递归的调用栈是怎样？"><a href="#尾递归的调用栈是怎样？" class="headerlink" title="尾递归的调用栈是怎样？"></a>尾递归的调用栈是怎样？</h3><p>我们先来看看尾递归求阶乘的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;####### 尾递归求阶乘 #######&apos;)</span><br><span class="line">def fact_tail(n):</span><br><span class="line"> return tail_fact_count(n)</span><br><span class="line"></span><br><span class="line">def tail_fact_count(n, result = 1):</span><br><span class="line"> if n == 1:</span><br><span class="line">  return result</span><br><span class="line"> else:</span><br><span class="line">  print(&apos;current: n = %d, result = %d&apos; % (n, result))</span><br><span class="line">  print(&apos;next: n = %d, result = %d&apos; % (n - 1, result * n))</span><br><span class="line">  print(&apos;----------------&apos;)</span><br><span class="line">  return tail_fact_count(n - 1, n * result)</span><br><span class="line"></span><br><span class="line">print(&apos;result = %s&apos; % fact_tail(4))</span><br></pre></td></tr></table></figure><p>同样的，我们将上述代码略作改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;####### 尾递归求阶乘 #######&apos;)</span><br><span class="line">def fact_tail(n):</span><br><span class="line"> result = tail_fact_count(n)</span><br><span class="line"> return result</span><br><span class="line"></span><br><span class="line">def tail_fact_count(n, result = 1):</span><br><span class="line"> if n == 1:</span><br><span class="line">  return result</span><br><span class="line"> else:</span><br><span class="line">  print(&apos;current: n = %d, result = %d&apos; % (n, result))</span><br><span class="line">  print(&apos;next: n = %d, result = %d&apos; % (n - 1, result * n))</span><br><span class="line">  print(&apos;----------------&apos;)</span><br><span class="line">  result = n * result</span><br><span class="line">  n = n - 1</span><br><span class="line">  return tail_fact_count(n, result)</span><br><span class="line"></span><br><span class="line">print(&apos;result = %s&apos; % fact_tail(4))</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">####### 尾递归求阶乘 #######</span><br><span class="line">current: n = 4, result = 1</span><br><span class="line">next: n = 3, result = 4</span><br><span class="line">----------------</span><br><span class="line">current: n = 3, result = 4</span><br><span class="line">next: n = 2, result = 12</span><br><span class="line">----------------</span><br><span class="line">current: n = 2, result = 12</span><br><span class="line">next: n = 1, result = 24</span><br><span class="line">----------------</span><br><span class="line">result = 24</span><br></pre></td></tr></table></figure><p>我们再来看看它的调用栈情况：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/17/160622c83bb8aebd?w=1240&amp;h=912&amp;f=png&amp;s=192491" alt="尾递归函数调用栈.png"></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/17/160622c83be2af8a?w=1240&amp;h=328&amp;f=png&amp;s=58090" alt="尾递归函数调用栈.png"></p><p>仔细对比前面递归函数的调用栈情况，我们可以看出递归与尾递归调用栈的两个明显不同点：</p><ol><li>尾递归的调用栈明显比递归的调用栈清爽很多。</li><li><strong>尾递归弹栈顺序是由上至下执行；而递归弹栈顺序是由下至上执行的。</strong>（这里的弹栈顺序指的不是物理顺序）</li></ol><p>我们再来看看前面递归函数的实现。在递归实现中，result的值因为需要 <strong>下一个递归函数返回的值</strong> 来计算才能确定，所以栈顶函数（设A）一直在调用栈中停留等待下一个栈顶函数（设B）的返回值，一旦下一个栈顶函数（B）返回了确切的result值，那么当B交待完成之后就会弹出，所谓交待即是因为上一个栈顶函数A需要下一个栈顶函数即B的返回值，当A拿到了B的值就是交待完成了。以此类推，递归的弹栈顺序则如图所示由下往上弹出。</p><p>那么尾递归究竟做了什么猫腻？</p><p>尾递归其实在result的值上做了猫腻。在尾递归的实现中，result的值在当前栈顶函数中已经确定下来了，并经计算后交待给下一个栈顶函数。所以当栈顶函数<strong>完成了它的使命（把result值传递给下一个执行函数）</strong>，它就会愉快的在调用栈上弹出。</p><p>归纳来讲:</p><ul><li>递归函数需要将整个函数作为上下文来完成 <strong>目的</strong>。</li><li>尾递归则把 <strong>目的</strong> 在当前函数中完成，并交待给下一个函数。</li></ul><p>在本例子中的 <strong>目的</strong> 指的是确定result值。</p><h3 id="为什么说尾递归的实现在本质上是跟循环等价？"><a href="#为什么说尾递归的实现在本质上是跟循环等价？" class="headerlink" title="为什么说尾递归的实现在本质上是跟循环等价？"></a>为什么说尾递归的实现在本质上是跟循环等价？</h3><p>按照惯例，先上代码。但是为了更好的理解与尾递归的联系，最好还是花个十几秒思考一下如何实现for循环求阶乘吧~</p><p>为了减少篇幅，直接贴上略作修改的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;####### for循环求阶乘 #######&apos;)</span><br><span class="line">def fact_for(n):</span><br><span class="line"> if n == 1:</span><br><span class="line">  return 1</span><br><span class="line"> else:</span><br><span class="line">  result = 1</span><br><span class="line">  for i in range(n, 0, -1):</span><br><span class="line">   print(&apos;current: n = %d, result = %d&apos; % (i, result))</span><br><span class="line">   result = for_fact_count(i, result)</span><br><span class="line">  return result</span><br><span class="line"></span><br><span class="line">def for_fact_count(n, result = 1):</span><br><span class="line"> return n * result</span><br><span class="line"></span><br><span class="line">print(&apos;result = %s&apos; % fact_for(4))</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">####### for循环求阶乘 #######</span><br><span class="line">current: n = 4, result = 1</span><br><span class="line">current: n = 3, result = 4</span><br><span class="line">current: n = 2, result = 12</span><br><span class="line">current: n = 1, result = 24</span><br><span class="line">result = 24</span><br></pre></td></tr></table></figure><p>当我们思考如何使用for循环去实现求阶乘的过程中，我们会想到用一个变量去存储计算的值。在上述代码中指的就是 <code>result (= 1)</code>。</p><p>为了便于理解for循环与尾递归，我设计了这么一个函数 <code>for_fact_count(n, result = 1)</code>，它接收 <strong>当前result值并经计算后刷新result值</strong>。</p><p>在不影响for循环的实现我已经将其与尾递归的实现做了相似的转化（连名字的都好相似啦），所以请开始你的表演，把for循环求阶乘的调用栈画出来吧~</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote><ul><li>虽说本文使用了Python进行编码解释，但是目前大多数编程语言都没有针对尾递归做优化，Python解释器也没有，所以即便使用了尾递归进行求阶乘，在运行过程中还是会造成栈溢出。而Xcode在debug环境下不会对尾递归做优化，需将其设为release。</li><li>小生才疏浅陋，文中难免有错漏之处，请多多指教，感谢您的阅读。</li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
